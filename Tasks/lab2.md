# Лабораторная работа 2 (Arithmetic)

## Общее описание
Целью работы является реализация иерархии generic структур данных на основе деревьев поиска. Все реализации должны соответствовать принципам SOLID и использовать паттерны проектирования.

+ Все задания реализуются на языке программирования C#14 . 
+ Реализованные в заданиях приложения не должны завершаться аварийно; **все** возникающие исключительные ситуации должны быть перехвачены и обработаны.
+ Во всех заданиях запрещено пользоваться функциями, позволяющими завершить выполнение приложения из произвольной точки выполнения.
+ Во всех заданиях при реализации необходимо разделять контексты работы с данными (поиск,сортировка, добавление/удаление, модификация и т. п.) и отправка данных в поток вывода /выгрузка данных из потока ввода.
+ Во всех заданиях все вводимые (с консоли, файла, командной строки) пользователем данные должны (если не сказано обратное) быть подвергнуты валидации в соответствии с типом валидируемых данных.
+ Во всех заданиях необходимо контролировать ситуации с невозможностью [пере]выделения памяти; во всех заданиях необходимо корректно освобождать всю выделенную динамическую память.
+ Все ошибки, связанные с операциями открытия файла, должны быть обработаны; все открытые файлы должны быть закрыты.
+ Реализованные компоненты должны зависеть от абстракций, а не от конкретных реализаций абстракций. 
+ Для задач, для которых написаны тесты, находящиется в `Arithmetic.Tests`, требуется демонстрация прохождения всех описанных тестов для реализованных компонентов. Модификация кода тестов запрещена


### 1. Класс длинного целого числа (BetterBigInteger)

**Путь в репозитории:** `/Arithmetic/BigInt/`

Реализуйте класс длинного целого числа `BetterBigInteger`, реализующий интерфейс `IBigInteger`. Класс должен быть спроектирован с учетом высокой эффективности использования памяти и поддерживать выполнение основных арифметических и поразрядных операций.

Данными объекта являются:
*   `int _signBit`: Поле для хранения знака числа (0 для положительных, 1 для отрицательных).
*   `uint _smallValue`: Поле для хранения значения числа, если оно помещается в один 32-битный машинный разряд.
*   `uint[]? _data`: Динамический массив (или `null`), хранящий цифры числа в системе счисления с основанием $2^{32}$ в формате **little-endian** (младшие разряды по младшим индексам).

Обеспечьте эффективность по памяти. Если число по модулю помещается в один 32-битный разряд (`uint`), оно должно храниться непосредственно в поле `_smallValue`, при этом ссылка на массив `_data` должна оставаться `null`. Массив `_data` инициализируется только в том случае, если для представления числа требуется более одного разряда.

Реализуйте следующие конструкторы:
1.  **От массива цифр:** принимает `uint[] digits` (в формате little-endian) и флаг отрицательности `bool isNegative`.
2.  **От перечисления:** принимает `IEnumerable<uint> digits` и флаг отрицательности.
3.  **От строкового представления:** принимает `string value` и основание системы счисления `int radix`. Конструктор должен корректно обрабатывать знаки числа.


Класс должен реализовывать следующие возможности:
*   **Свойства и методы:**
    *   `IsNegative`: свойство, возвращающее `true`, если число отрицательное.
    *   `GetDigits()`: возвращает `ReadOnlySpan<uint>` для доступа к цифрам числа (с учетом SIO).
    *   `ToString(int radix)`: преобразование числа в строку в заданной системе счисления.
*   **Сравнения (интерфейсы `IComparable` и `IEquatable`):**
    *   Операторы отношения: `==`, `!=`, `<`, `>`, `<=`, `>=`.
    *   Переопределение методов `Equals` и `GetHashCode`.
*   **Арифметические операции:**
    *   Бинарные операторы: `+`, `-`, `/`, `%`. 
    *   Унарный минус: `-a`.
*   **Поразрядные операции и сдвиги:**
    *   Поразрядные: `~` (инверсия), `&` (И), `|` (ИЛИ), `^` (исключающее ИЛИ).
    *   Битовые сдвиги: `<<`, `>>`.


### 2: Умножение «в столбик» (Simple Multiplication)

**Путь в репозитории:**  `Arithmetic/BigInt/MultiplyStrategy`

Реализуйте класс `SimpleMultiplier`, реализующий интерфейс `IMultiplier`.
1. **Алгоритм:** Реализуйте классическое умножение чисел «в столбик» (алгоритм школьного умножения).
2. **Интеграция:** В классе `BetterBigInteger` настройте операторы умножения так, чтобы они делегировали выполнение операции методу `Multiply` данной стратегии (как базовый вариант).
3. **Требования:** Метод должен принимать два массива `uint[]` и возвращать массив `uint[]`, представляющий произведение. Корректно обрабатывайте переносы разрядов.

---

### Задача 2: Умножение методом Карацубы (Karatsuba Multiplication)
**Путь в репозитории:**  `Arithmetic/BigInt/MultiplyStrategy`

Реализуйте класс `KaratsubaMultiplier`, реализующий интерфейс `IMultiplier`.
1. **Алгоритм:** Реализуйте рекурсивный алгоритм Карацубы, основанный на принципе «разделяй и властвуй».
2. **Требования:** Реализуйте эффективное разбиение массивов `uint[]` на старшие и младшие части без лишнего копирования памяти (используя `ReadOnlySpan<uint>` там, где это возможно).
3. **Демонстрация:** Проведите сравнение производительности с `SimpleMultiplier` на больших числах.

---

### Задача 3: Умножение Шёнхаге — Штрассена (FFT Multiplication)
**Путь в репозитории:**  `Arithmetic/BigInt/MultiplyStrategy`

Реализуйте класс `FftMultiplier`, реализующий интерфейс `IMultiplier`.
1. **Алгоритм:** Реализуйте алгоритм на основе быстрого преобразования Фурье (FFT).
2. **Интеграция в BetterBigInteger:** Реализуйте логику автоматического выбора стратегии в операторе `*`. Класс `BetterBigInteger` должен выбирать `FftMultiplier` только в том случае, если количество разрядов в числах превышает определенный порог (настраиваемый или эмпирически определенный).
3. **Демонстрация:** Проведите сравнение производительности с `SimpleMultiplier` и `KaratsubaMultiplier` на больших числах.

---
